---
layout: post
title: 浅谈malloc()与free()
category: 技术
tags: 内存分配|C语言
description: 
---
#malloc()与free()
##函数原型

malloc函数的函数原型为：void* malloc（unsigned int size），它根据参数指定的尺寸来分配内存块，并且返回一个void型指针，指向新分配的内存块的初始位置。如果内存分配失败（内存不足），则函数返回NULL。

##关于返回值

malloc的返回值为void*。我们在使用的时候，习惯对返回值进行强制类型转换：

char * p = NULL;

p = (char *)malloc(sizeof(char));

ANSI C以前的C，因为没有void*这种类型，malloc函数的返回值被简单地定义为char*，char*是不能被赋予指向其他类型变量的指针的。所以在使用malloc函数时通常需要对其返回值进行强制类型转换。

在ANSI C中，malloc函数的返回值为void*。void*类型是可以直接赋值给其他任何类型的指针。所以，上面的强制类型转换操作现在已经不需要了。

然而在c++中，任何类型的指针都可以赋给void*，而void*却不可以赋给其他类型的指针，所以在c++中使用malloc函数的时候，强制类型转换是必须的。另一方面，在c++中应该使用new来分配内存。

##malloc在堆上分配内存

malloc函数分配的内存是在堆（heap）上的。操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样代码中的delete或free语句才能正确的释放本内存空间。我们常说的内存泄露，最常见的就是堆泄露（还有资源泄露），它是指程序在运行中出现泄露，如果程序被关闭掉的话，操作系统会帮助释放泄漏的内存。

##malloc的使用

malloc函数使用起来倒是挺简单的，主要的使用范例有两种：一是动态分配结构体，通常用于被称为“链表”的数据结构中；二是分配可变长度的数组。对这两种用法就不多说了，主要是来看使用过程中的注意点：

调用malloc函数后，应该对函数返回值进行检查。前面说过，内存分配一旦失败，malloc（）会返回NULL。
char * p = NULL;
p = (char *)malloc(sizeof(char));
if(!p)
     exit(1);
在程序结束时，应该调用free函数对malloc函数分配的内存进行释放。
实际上，c语言标准没有规定要这么做，而且普通的PC上的操作系统，在进程结束时，肯定会释放曾经分配给当前进程的内存空间，也就是说，在程序结束之前，没有必要调用free（）。但是，对于一串连续的程序处理事件，如果先前程序分配的内存没有及时释放掉，那后面的工作就遭殃了。所以”malloc与free配套出现”还是相当合理的。

##malloc（）与free( )

从操作系统一次性地取得比较大的内存，当程序调用malloc（）时，malloc（）便将内存”零售”给应用程序，这是malloc（）的大体实现。而当这块一次性取出来的内存不够用的时候，就请求操作系统对空间进行扩容。多次调用malloc（）（导致内存不够用了）会调用一次brk（），内存区域向地址较大的一方伸长。malloc()分配内存，会用到brk(用于小内存申请<=128kb，在堆上)或mmap2(用于大内存申请，一般是堆和栈中间)系统调用 。

K&R中记录了malloc（）最简单的一种实现方式：通过链表来实现。malloc管理的空间不一定是连续的，空闲存储空间以空闲块链表的方式组织。在这种方式下，每个块之前都加上了一个管理区域，包含一个长度、一个指向下一块的指针以及一个指向自身存储空间的指针。这些快按照储存地址的升序组织。最后一块（最高地址）指向第一块。这里使用K&R中的图加以说明：

*<center><img src="/public/img/125.png" style="width:50%"></center>*

当有申请要求时，malloc将扫描空闲块链表，直到找到一块足够大的空闲块为止，如果找不到，则向操作系统申请一个大块并加入到空闲链表中。然而在这种内存管理方式的运行环境中，一旦数组越界检查发生错误，越过了malloc()分配的内存区域写入了数据，将会破坏下一个块的管理区域，容易造成程序崩溃。在《UNIX环境高级编程》中有一段话肯定了以上的说法：

 

“大多数实现所分配的存储空间比所要求的要稍大一些，额外的空间用来记录管理信息——分配块的长度，指向下一个分配块的指针等等。这就意味着如果写过一个已分配区的尾端，则会改写后一块的管理信息。这种类型的错误是灾难性的，但是因为这种错误不会很快就暴露出来，所以也就很难发现。将指向分配块的指针向后移动也可能会改写本块的管理信息。”

 
那么，free()在这里做了什么呢？free()将管理区域的标记改为”空块”，顺便也将上下空块合并成一个块，这样也防止了块的碎片化。这么说来，free（）函数在调用后，对应的内存是不会立刻返还给操作系统的（还在空闲链表里呆着）。也就是说，调用了free()之后，对应内存的内容不会马上被破坏，直到该块内存被重新分配，里面的内容才会被覆盖重写。尽管如此，调用free()之后，是不能引用对应的内存区域的。所以仓促地使用free（）是不对的，特别是当有两个指针指向同一块内存时，指针1把内存释放了，而指针2还指向那块内存，然而指针2已经不能进行解引用了。

这么看来，free()函数实际上并没有做”释放”的实际操作，它只是改变一些状态，告知操作系统某块内存可以去释放。至于如何告诉，还需要后续了解。