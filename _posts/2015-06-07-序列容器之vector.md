---
layout: post
title: 【C++】序列容器之Vector
category: 技术
tags: C＋＋｜对象模型
description: 
---

##什么是容器
容器，顾名思义，是用来容放东西的场所。C++容器容放某种数据结构，以利于对数据的搜寻或排序或其他特殊目的。众所周知，常用的数据结构不外乎：数组**array**,  链表**list**，  树**tree**，  栈**stack**，  队列**queue**，  散列表**hash table**,  集合**set**、映射表**map** 等等。容器便是容纳这些数据结构的。这些数据结构分为序列式与关联式两种，故容器也分为序列式容器和关联式容器。

*<center><img src="/public/img/109.png" style="width:50%"></center>*
##vector 概述
###vector是STL提供的一种序列式容器
所谓序列式容器，其中的元素都序，但未必有序，即元素集合呈线性关系排列，但未必是有序的。C++本身带了一种序列式容器array，STL再提供其他的序列式容器：vector，list，deque,stack，queue，priority-queue等。
###vector底层为动态数组
vector的数据安排以及操作方式与C++的array十分相似，它们间的唯一差别在于对空间的运用灵活性上。array为静态数组，有着静态数组最大的缺点：每次只能分配一定大小的存储空间，当有新元素插入时，要经历  “找到更大的内存空间”->“把数据复制到新空间” ->“销毁旧空间” 三部曲， 且对于array而言，这种空间任务压在使用它的用户身上，用户必须把握好数据的数量，尽量在第一次分配时就给数据分配合理的空间（这有时很难做到），以防止“三部曲”带来的代价，而数据溢出也是静态数组使用者需要注意的问题。

而vector用户不需要亲自处理空间运用问题。vector是动态空间，随着新元素的插入，旧存储空间不够用时，vector内部机制会自行扩充空间以容纳新元素，当然，这种空间扩充大部分情况下（几乎是）也逃脱不了“三部曲”，只是不需要用户自己处理，而且vector处理得更加安全高效。vector的实现技术关键就在于对其大小的控制以及重新配置时数据移动效率。
###vector的迭代器
对于C语言的数组，我们使用普通指针就可以对数组进行各种操作。vector维护的是一个连续线性空间，与数组array一样，所以无论其元素型别为何，普通指针都可以作为vector的迭代器而满足所有必要的条件。vector所需要的迭代器操作，包括operator*,operator->,operator++,operator--,operator+=,operator-=等，普通指针都具有。

故，**普通指针即可满足vector对迭代器的需求**。所以，vector提供了Random Access Iterators。
###vector的数据结构
正如上面所说，vector底层为连续线性空间。它使用两个迭代器：begin与finish该连续线性空间中的第一个元素的位置与超出末端的第一位位置，这两个迭代器标志了连续线性空间的已使用范围，并以end_of_storage迭代器标准整个连续线性空间的尾端。这里begin与finish符合STL“前开后闭”的标准。

*<center><img src="/public/img/110.png" style="width:50%"></center>*

基于这三个迭代器，可以完成许多操作。包括提供首尾标示、大小、容量、空容器判断、[]运算符、最前端元素值、最后端元素值等等。

值得注意的是，容器的大小与容量是不一样的概念。只有在容器满载时，大小才等于容器。在上面这张图中，大小size为已使用的存储空间长度，而容量为**已使用+未使用**的存储空间长度。从它们的实现代码上也可以看出来：

<pre><code>
size_type size() const
{
      return size_type( end() - begin() ) ;
}

size_type capacity () const
{
     return size_type( end_of_storage - begin() );
}
</code></pre>
###vector的内存分配策略
标准库的实现者使用了这样的内存分配策略：以最小的代价连续存储元素。为了使vector容器实现快速的内存分配，其实际分配的容量要比当前所需的空间多一些，vector容器预留了这些额外的存储区用于存放添加的新元素，于是不必为每个新元素进行一次内存分配。当继续向容器中加入元素导致备用空间被用光（超过了容量 capacity），此时再加入元素时vector的内存管理机制便会扩充容量至两倍，如果两倍容量仍不足，就扩张至足够大的容量。容量扩张必须经历“重新配置、元素移动、释放原空间”这个浩大的工程。按照《STL源码剖析》中提供的vector源码，vector的内存配置原则为：

- 如果vector原大小为0，则配置1，也即一个元素的大小。


- 如果原大小不为0，则配置原大小的两倍。


当然，vector的每种实现都可以自由地选择自己的内存分配策略，分配多少内存取决于其实现方式，不同的库采用不同的分配策略。

需要注意的是，使用vector迭代器时要时刻注意vector是否发生了扩容，一旦扩容引起了空间重新配置，指向原vector的所有迭代器都将失效。　

关于vector各种接口的使用方法这里就不再赘述了。对于vector有新认识会及时更新博文。