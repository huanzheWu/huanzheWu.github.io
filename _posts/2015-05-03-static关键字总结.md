---
layout: post
title: 【C++】static关键字总结
category: 技术
tags: C＋＋｜对象模型
description: 
---

static，即静态声明。它在 作用域、存储方式、生命周期 等各方面影响一个变量或函数。文章将从 局部变量、全局变量、普通函数、类的static成员（包括数据成员与成员函数）来总结static。

###全局变量
所有的全局变量，无论是否是static的，都是存储于静态存储区的。全局变量本身就是静态存储方式，将全局变量声明为static是为了将变量的作用域限制在本翻译单元中（本源文件中），使该全局变量不能被源程序的其他翻译单元所引用。普通全局变量使用extren声明可以拓展其作用域至其他翻译单元中。

可以总结为：static改变了全局变量的作用域，而不改变变量的存储位置与生命周期。　　
###局部变量　　　
局部变量即在函数内定义的或在块中定义的变量。static对局部变量的作用不同于全局变量。普通局部变量在离开其作用域（如离开定义它的函数或块的花括号）时即消失，而static变量却存在于程序运行的整个过程，也即是说，static声明改变了局部变量的生命周期。普通局部变量是存储在动态存储区的（堆），而static局部变量是存储在静态存储区，因而普通局部变量在函数每次被调用时都被重新分配内存地址，而静态局部变量则在程序运行过程中占据固定的内存。

可以总结为：static改变了局部变量的存储方式与生命周期，而不改变变量的作用域。

###普通函数
这里的普通函数是为了与类的成员函数区别开来。函数在定义时默认是外部的，通过extren声明即可被其他源文件引用，static声明将函数的作用域限制在本翻译单元中，成为内部函数。static函数在内存中只有一份，普通函数在每个调用中维持一份拷贝。

可以总结为：static使得函数在内存中只有一份，并将函数作用域限制在当前源文件。

另外，static有几个优点总被提起：

1. 避免了链接时与其他源文件中的变量命名引起冲突。
2. 对于c函数而言，static对函数进行了信息屏蔽，只给当前文件中其他函数使用。

###类static成员
static声明对类成员的作用可以这样概括：static使得成员从“属于类对象”变成了“属于类，而不属于类对象”。

对于数据成员：

1. static数据成员必须在类定义体的外部进行定义。


<pre><code>
class BOOK
{
    private:
        //折扣
        static float discount;
};
//在类定义体外部定义并初始化
float BOOK::discount = 0.95f;
</code></pre>


 2.不像普通数据成员，static数据成员不能在构造函数中进行初始化。正如上面所说，它只能在类外部定义并初始化。然而有一个例外，整型的const static 数据成员可以在类的定义体中进行初始化。但需注意的是，const static数据成员在类的定义体中初始化时，该数据成员仍必须在类的定义体之外进行定义（不必再指定初始值了）。

<pre><code>
class BOOK
{
    private:
        //折扣
        const static  int  discount=1;
};
const  int BOOK::discount;
</code></pre>

###类static成员函数
在类内部声明的static成员函数，在类定义体外部进行定义时无须重复指定static关键字。

对于static成员函数，它同样是不属于类对象的，因而它没有this指针。它可以直接访问类的static数据成员，不能直接使用非static成员，原因是非static数据成员属于类对象，使用非static数据成员时必须通过this指针来确定是这些成员属于哪个类对象，然而上面说了，static成员函数没有this指针。

static成员函数不能被声明为const。实际上，成员函数被声明为const的本质是它向编译器保证不会通过这个函数来修改类对象在内存中的每一个bit的内容（可以看《effective C++》 条款03 “尽可能使用const” ），然而我们知道，static成员函数并不属于类对象，更谈不上要保证不修改某一对象的内存了。

另外，虚函数不能为声明为static，为什么呢？原因还是static成员函数没有this指针。virtual funtion运行时绑定是多态的基础，没有this指针多态的概念无法践行。　　

######PS：如果文章内容有错误，恳请指出，万分感谢。